use noir_symmetric_crypto::chacha20::ChaCha20;

// component main{public [in, nonce, counter]} = ChaCha20(32, 32);
fn main(
    // Private input
    key: [u32; 8],
    // Public inputs
    nonce: pub [u32; 3],
    counter: pub u32,
    plaintext: pub [u32; 32],
    ciphertext: pub [u32; 32],
) {
    let output = ChaCha20::<32>(key, nonce, counter, plaintext);
    assert(output == ciphertext);
}

// Test case from RCF https://www.rfc-editor.org/rfc/rfc7539.html#section-2.4.2
#[test]
fn test_chacha20_main_64_bytes() {
    let key = [
        0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918,
        0x1f1e1d1c,
    ];
    let nonce: [u32; 3] = [0x00000000, 0x4a000000, 0x00000000];
    let counter: u32 = 1;

    // "Ladies and Gentlemen of the class of '99: If I could offer you o"
    let plaintext: [Field; 64] = [
        0x4c, 0x61, 0x64, 0x69, 0x65, 0x73, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x47, 0x65, 0x6e, 0x74,
        0x6c, 0x65, 0x6d, 0x65, 0x6e, 0x20, 0x6f, 0x66, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6c,
        0x61, 0x73, 0x73, 0x20, 0x6f, 0x66, 0x20, 0x27, 0x39, 0x39, 0x3a, 0x20, 0x49, 0x66, 0x20,
        0x49, 0x20, 0x63, 0x6f, 0x75, 0x6c, 0x64, 0x20, 0x6f, 0x66, 0x66, 0x65, 0x72, 0x20, 0x79,
        0x6f, 0x75, 0x20, 0x6f,
    ];

    let ciphertext: [u8; 64] = [
        0x6e, 0x2e, 0x35, 0x9a, 0x25, 0x68, 0xf9, 0x80, 0x41, 0xba, 0x07, 0x28, 0xdd, 0x0d, 0x69,
        0x81, 0xe9, 0x7e, 0x7a, 0xec, 0x1d, 0x43, 0x60, 0xc2, 0x0a, 0x27, 0xaf, 0xcc, 0xfd, 0x9f,
        0xae, 0x0b, 0xf9, 0x1b, 0x65, 0xc5, 0x52, 0x47, 0x33, 0xab, 0x8f, 0x59, 0x3d, 0xab, 0xcd,
        0x62, 0xb3, 0x57, 0x16, 0x39, 0xd6, 0x24, 0xe6, 0x51, 0x52, 0xab, 0x8f, 0x53, 0x0c, 0x35,
        0x9f, 0x08, 0x61, 0xd8,
    ];

    // Plaintext: "Ladies and Gentlemen of the class of '99: If I could o"
    // Total: 64 bytes, which needs 16 u32 words (rounded up to 32 for ChaCha20)
    let plaintext: [u32; 16] = [
        // Bytes [0-3]:   4c 61 64 69 -> 0x6964614c (little-endian)
        0x6964614c, 0x61207365, 0x4720646e, 0x6c746e65, 0x6e656d65, 0x20666f20, 0x20656874,
        0x73616c63, 0x666f2073, 0x39392720, 0x6649203a, 0x63204920, 0x646c756f, 0x66666f20,
        0x79207265, 0x6f20756f,
    ];

    // ciphertext (114 bytes -> 29 u32 words, padded to 32)
    let ciphertext: [u32; 16] = [
        // Bytes [0-3]:   6e 2e 35 9a -> 0x9a352e6e
        0x9a352e6e, 0x80f96825, 0x2807ba41, 0x81690ddd, 0xec7a7ee9, 0xc260431d, 0xccaf270a,
        0x0bae9ffd, 0xc5651bf9, 0xab334752, 0xab3d598f, 0x57b362cd, 0x24d63916, 0xab5251e6,
        0x350c538f, 0xd861089f,
    ];

    let output = ChaCha20::<16>(key, nonce, counter, plaintext);
    assert(output == ciphertext);
}

// Plaintext: "Ladies and Gentlemen of the class of '99: If I could offer you only one tip for the future, sunscreen would be it."
// Total: 114 bytes, which needs 29 u32 words (rounded up to 32 for ChaCha20)
#[test]
fn test_chacha20_main_114_bytes() {
    // Test vector from RFC 7539 Section 2.4.2
    let key = [
        0x03020100, 0x07060504, 0x0b0a0908, 0x0f0e0d0c, 0x13121110, 0x17161514, 0x1b1a1918,
        0x1f1e1d1c,
    ];
    let nonce = [0x00000000, 0x4a000000, 0x00000000];
    let counter = 1;

    // "Ladies and Gentlemen of the class of '99: If I could offer you only one tip for the future, sunscreen would be it."
    let plaintext: [u32; 32] = [
        0x6964614c, 0x61207365, 0x4720646e, 0x6c746e65, 0x6e656d65, 0x20666f20, 0x20656874,
        0x73616c63, 0x666f2073, 0x39392720, 0x6649203a, 0x63204920, 0x646c756f, 0x66666f20,
        0x79207265, 0x6f20756f, 0x20796c6e, 0x20656e6f, 0x20706974, 0x20726f66, 0x20656874,
        0x75747566, 0x202c6572, 0x736e7573, 0x65657263, 0x6f77206e, 0x20646c75, 0x69206562,
        0x00002e74, 0x00000000, 0x00000000, 0x00000000,
    ];

    let ciphertext: [u32; 32] = [
        0x9a352e6e, 0x80f96825, 0x2807ba41, 0x81690ddd, 0xec7a7ee9, 0xc260431d, 0xccaf270a,
        0x0bae9ffd, 0xc5651bf9, 0xab334752, 0xab3d598f, 0x57b362cd, 0x24d63916, 0xab5251e6,
        0x350c538f, 0xd861089f, 0xbf0dca07, 0x616a0d50, 0x088ea356, 0x5eb6228a, 0x4d51bc52,
        0x06f8cc16, 0x1ae98c81, 0x363779b7, 0xbf0bf95a, 0xe65ba374, 0xed8e0bb4, 0x425e78f2,
        0x3744d87, 0xa11a2073, 0xe8bcfb88, 0xedc49139,
    ];

    main(key, nonce, counter, plaintext, ciphertext);
}
